const {
  User,
  UserPoints,
  Review,
  UserFavorite,
  Reservation,
  Restaurant,
  UserAdmin,
} = require('../../models');
const { sequelize } = require('../../models');
const { deleteFromS3 } = require('../../utils/s3Delete');
const { Op } = require('sequelize');
const bcrypt = require('bcrypt');
const { getMediaUrl } = require('../../config/cdn');
const {
  uploadImage,
  UPLOAD_STRATEGY,
} = require('../../services/imageUploadService');

const updateUserLanguage = async (req, res) => {
  const { language } = req.body;
  const user = await User.findByPk(req.user.id);
  await user.update({ language });
  res.status(200).json({ message: 'Language updated successfully' });
};

const getUserLanguage = async (req, res) => {
  const user = await User.findByPk(req.user.id);
  if (!user) {
    return res.status(404).json({ error: 'User not found' });
  }
  res.status(200).json({ language: user.language });
};

const getUserById = async (req, res) => {
  try {
    const { id } = req.params;
    const user = await User.findByPk(id);
    if (!user) {
      return res.status(404).json({ error: 'User not found' });
    }
    res.status(200).json(user);
  } catch (error) {
    console.error('Error fetching user by ID:', error);
    res.status(500).json({ error: 'Failed to fetch user' });
  }
};

const getUserProfile = async (req, res) => {
  try {
    const userId = req.user.id;
    const user = await User.findByPk(userId, {
      attributes: [
        'id',
        'name',
        'username',
        'gender',
        'bio',
        'instagramUrl',
        'tiktokUrl',
        'profileImage',
        'streetAddress',
        'city',
        'country',
        'phone',
        'email',
        'birthDate',
      ],
      include: [
        {
          model: UserPoints,
          as: 'points',
          attributes: ['totalPoints', 'level'],
        },
      ],
    });

    if (!user) {
      return res.status(404).json({ error: 'User not found' });
    }

    // Dohvati sve restorane gdje je user owner preko UserAdmin
    const adminLinks = await UserAdmin.findAll({
      where: { userId, role: 'owner' },
      attributes: ['restaurantId'],
    });
    const restaurantIds = adminLinks.map((link) => link.restaurantId);
    const ownedRestaurants =
      restaurantIds.length > 0
        ? await Restaurant.findAll({
            where: { id: restaurantIds },
            attributes: ['id', 'name', 'place'],
          })
        : [];

    const [reviewCount, favoriteCount, completedReservationsCount] =
      await Promise.all([
        Review.count({ where: { userId } }),
        UserFavorite.count({ where: { userId } }),
        Reservation.count({ where: { userId, status: 'completed' } }),
      ]);

    const response = {
      id: user.id,
      name: user.name,
      username: user.username,
      email: user.email,
      phone: user.phone,
      gender: user.gender,
      bio: user.bio,
      instagramUrl: user.instagramUrl,
      tiktokUrl: user.tiktokUrl,
      birthDate: user.birthDate,
      profileImage: user.profileImage
        ? getMediaUrl(user.profileImage, 'image', 'original')
        : null,
      location: {
        street: user.streetAddress,
        city: user.city,
        country: user.country,
      },
      stats: {
        points: user.points?.totalPoints || 0,
        level: user.points?.level || 1,
        reviewCount,
        favoriteCount,
        completedReservationsCount,
      },
      isRestaurantOwner: ownedRestaurants.length > 0,
      ownedRestaurants: ownedRestaurants.map((r) => ({
        id: r.id,
        name: r.name,
        city: r.place,
      })),
    };

    res.status(200).json(response);
  } catch (error) {
    console.error('Error fetching user profile:', error);
    res.status(500).json({ error: 'Failed to fetch user profile' });
  }
};

const updateUserProfile = async (req, res) => {
  try {
    const userId = req.user.id;
    const {
      name,
      username,
      gender,
      bio,
      instagramUrl,
      tiktokUrl,
      streetAddress,
      city,
      country,
      phone,
      birthDate,
      email,
    } = req.body;

    const user = await User.findByPk(userId);
    if (!user) {
      return res.status(404).json({ error: 'User not found' });
    }

    // Ažuriramo samo poslane podatke
    const updates = {};
    if (name !== undefined) updates.name = name;

    // Posebno rukovanje username-om - dozvoli promjenu samo svaka 2 tjedna
    if (username !== undefined && username !== user.username) {
      // Check if current username is auto-generated (user_XXXXXX format)
      const isAutoGeneratedUsername = /^user_\d{6}$/.test(user.username);

      // Allow change if:
      // 1. Username was never changed before (usernameLastChanged is null)
      // 2. OR current username is auto-generated
      // 3. OR 2 weeks have passed since last change
      if (user.usernameLastChanged && !isAutoGeneratedUsername) {
        const twoWeeksAgo = new Date();
        twoWeeksAgo.setDate(twoWeeksAgo.getDate() - 14);

        if (new Date(user.usernameLastChanged) > twoWeeksAgo) {
          const nextChangeDate = new Date(user.usernameLastChanged);
          nextChangeDate.setDate(nextChangeDate.getDate() + 14);

          return res.status(400).json({
            error: 'You can only change your username once every 2 weeks',
            nextChangeAvailable: nextChangeDate.toISOString(),
          });
        }
      }

      // Provjeri je li username već zauzet
      const existingUser = await User.findOne({
        where: {
          username,
          id: { [Op.ne]: userId },
        },
      });

      if (existingUser) {
        return res.status(400).json({
          error: 'This username is already taken',
        });
      }

      updates.username = username;
      updates.usernameLastChanged = new Date();
    }

    if (gender !== undefined) updates.gender = gender;
    if (bio !== undefined) updates.bio = bio;
    if (instagramUrl !== undefined) updates.instagramUrl = instagramUrl;
    if (tiktokUrl !== undefined) updates.tiktokUrl = tiktokUrl;
    if (streetAddress !== undefined) updates.streetAddress = streetAddress;
    if (city !== undefined) updates.city = city;
    if (country !== undefined) updates.country = country;
    if (birthDate !== undefined) updates.birthDate = birthDate;

    let emailChanged = false;
    let phoneChanged = false;

    // Posebno rukovanje email adresom ako je poslana
    if (email !== undefined && email !== user.email) {
      // Normalize email to lowercase for consistency
      const normalizedEmail = email.toLowerCase().trim();

      // Provjeri postoji li već taj email kod drugog korisnika
      const existingUser = await User.findOne({
        where: {
          email: normalizedEmail,
          id: { [Op.ne]: userId }, // isključi trenutnog korisnika
        },
      });

      if (existingUser) {
        return res.status(400).json({
          error: 'This email address is already in use by another user',
        });
      }

      updates.email = normalizedEmail;
      emailChanged = true;
    }

    // Posebno rukovanje telefonskim brojem
    if (phone !== undefined) {
      // Ako je broj isti kao trenutni, preskočimo ažuriranje
      if (phone === user.phone) {
        // Ne radimo ništa, korisnik je poslao isti broj
      } else {
        // Provjeri postoji li već taj broj kod drugog korisnika
        const existingUser = await User.findOne({
          where: {
            phone: phone,
            id: { [Op.ne]: userId }, // isključi trenutnog korisnika
          },
        });

        if (existingUser) {
          return res.status(400).json({
            error: 'This phone number is already in use by another user',
          });
        }

        updates.phone = phone;
        phoneChanged = true;
      }
    }

    await user.update(updates);

    // Ako je email promijenjen, postavimo isEmailVerified na false u UserSettings
    if (emailChanged) {
      const { UserSettings } = require('../../models');
      const userSettings = await UserSettings.findOne({ where: { userId } });
      if (userSettings) {
        await userSettings.update({ isEmailVerified: false });
      }
    }

    if (phoneChanged) {
      const { UserSettings } = require('../../models');
      const userSettings = await UserSettings.findOne({ where: { userId } });
      if (userSettings) {
        await userSettings.update({ isPhoneVerified: false });
      }
    }

    // Vraćamo ažurirane podatke
    const updatedUser = await User.findByPk(userId, {
      attributes: [
        'id',
        'name',
        'username',
        'gender',
        'bio',
        'instagramUrl',
        'tiktokUrl',
        'streetAddress',
        'city',
        'country',
        'phone',
        'email',
        'birthDate',
      ],
    });

    const response = {
      id: updatedUser.id,
      name: updatedUser.name,
      username: updatedUser.username,
      gender: updatedUser.gender,
      bio: updatedUser.bio,
      instagramUrl: updatedUser.instagramUrl,
      tiktokUrl: updatedUser.tiktokUrl,
      location: {
        street: updatedUser.streetAddress,
        city: updatedUser.city,
        country: updatedUser.country,
      },
      contact: {
        phone: updatedUser.phone,
        email: updatedUser.email,
      },
      birthDate: updatedUser.birthDate,
    };

    // Dodajemo poruku o verifikaciji ako je email promijenjen
    if (emailChanged) {
      response.message =
        'Profile updated successfully. Please verify your new email address.';
    }

    res.status(200).json(response);
  } catch (error) {
    console.error('Error updating user profile:', error);
    res.status(500).json({ error: 'Failed to update user profile' });
  }
};

const getUserStats = async (req, res) => {
  try {
    const userId = req.user.id;

    const [userPoints, reviewStats, favoriteRestaurants, reservationStats] =
      await Promise.all([
        // Bodovi i level
        UserPoints.findOne({
          where: { userId },
          attributes: ['totalPoints', 'level'],
        }),

        // Statistika recenzija
        Review.findAll({
          where: { userId },
          attributes: [
            [sequelize.fn('COUNT', sequelize.col('id')), 'total'],
            [sequelize.fn('AVG', sequelize.col('rating')), 'averageRating'],
            [sequelize.fn('MAX', sequelize.col('createdAt')), 'lastReviewDate'],
          ],
        }),

        // Omiljeni restorani
        UserFavorite.findAll({
          where: { userId },
          include: [
            {
              model: Restaurant,
              as: 'restaurant',
              attributes: ['id', 'name'],
            },
          ],
          limit: 5,
          order: [['createdAt', 'DESC']],
        }),

        // Statistika rezervacija
        Reservation.findAll({
          where: { userId },
          attributes: [
            'status',
            [sequelize.fn('COUNT', sequelize.col('id')), 'count'],
          ],
          group: ['status'],
        }),
      ]);

    // Izračunaj pointsToNextLevel
    const calculatePointsToNextLevel = (currentLevel, totalPoints) => {
      const levelThresholds = {
        1: 100,
        2: 250,
        3: 500,
        4: 1000,
        5: Infinity,
      };
      return levelThresholds[currentLevel] - totalPoints;
    };

    // Formatiramo statistiku rezervacija
    const reservationCounts = {
      completed: 0,
      pending: 0,
      cancelled: 0,
    };
    reservationStats.forEach((stat) => {
      reservationCounts[stat.status] = parseInt(stat.get('count'));
    });

    const response = {
      points: {
        total: userPoints?.totalPoints || 0,
        level: userPoints?.level || 1,
        pointsToNextLevel: calculatePointsToNextLevel(
          userPoints?.level || 1,
          userPoints?.totalPoints || 0,
        ),
      },
      reviews: {
        total: parseInt(reviewStats[0].get('total')) || 0,
        averageRating: parseFloat(reviewStats[0].get('averageRating')) || 0,
        lastReviewDate: reviewStats[0].get('lastReviewDate'),
      },
      favorites: {
        total: favoriteRestaurants.length,
        recent: favoriteRestaurants.map((fav) => ({
          id: fav.restaurant.id,
          name: fav.restaurant.name,
        })),
      },
      reservations: {
        ...reservationCounts,
        total: Object.values(reservationCounts).reduce((a, b) => a + b, 0),
      },
    };

    res.status(200).json(response);
  } catch (error) {
    console.error('Error fetching user stats:', error);
    res.status(500).json({ error: 'Failed to fetch user statistics' });
  }
};

const updateProfileImage = async (req, res) => {
  try {
    const userId = req.user.id;
    const file = req.file;

    if (!file) {
      return res.status(400).json({ error: 'No image provided' });
    }

    const user = await User.findByPk(userId);
    if (!user) {
      return res.status(404).json({ error: 'User not found' });
    }

    // If user already has a profile image, delete it from S3
    if (user.profileImage) {
      await deleteFromS3(user.profileImage);
    }

    // Upload new image to S3 with QUICK strategy (fast, thumbnail only)
    const folder = 'user_profile_images';
    let imageUrl = null;
    let imageUploadResult = null;
    try {
      imageUploadResult = await uploadImage(file, folder, {
        strategy: UPLOAD_STRATEGY.QUICK,
        maxWidth: 400, // Thumbnail size for profile pictures
        quality: 85, // Good balance between quality and speed
      });
      imageUrl = imageUploadResult.imageUrl;
    } catch (uploadError) {
      console.error('Error uploading to S3:', uploadError);
      return res.status(500).json({ error: 'Failed to upload image' });
    }

    // Update user's profile image
    await user.update({ profileImage: imageUrl });

    res.json({
      message: 'Profile image updated successfully',
      imageUrl: imageUrl ? getMediaUrl(imageUrl, 'image', 'original') : null,
    });
  } catch (error) {
    console.error('Error updating profile image:', error);
    res.status(500).json({ error: 'Failed to update profile image' });
  }
};

const deleteProfileImage = async (req, res) => {
  try {
    const userId = req.user.id;
    const user = await User.findByPk(userId);

    if (!user) {
      return res.status(404).json({ error: 'User not found' });
    }

    if (!user.profileImage) {
      return res.status(400).json({ error: 'No profile image to delete' });
    }

    // Delete image from S3 (single file with QUICK strategy)
    await deleteFromS3(user.profileImage);

    // Update user's profile image to null
    await user.update({ profileImage: null });

    res.json({ message: 'Profile image deleted successfully' });
  } catch (error) {
    console.error('Error deleting profile image:', error);
    res.status(500).json({ error: 'Failed to delete profile image' });
  }
};

const changePassword = async (req, res) => {
  try {
    const userId = req.user.id;
    const { currentPassword, newPassword } = req.body;

    // Provjeri jesu li poslani svi potrebni podaci
    if (!currentPassword || !newPassword) {
      return res
        .status(400)
        .json({ error: 'Both current password and new password are required' });
    }

    // Provjeri ako nove lozinke odgovaraju minimalnim zahtjevima (npr. duljina)
    if (newPassword.length < 8) {
      return res
        .status(400)
        .json({ error: 'New password must be at least 8 characters long' });
    }

    // Dohvati korisnika
    const user = await User.findByPk(userId);
    if (!user) {
      return res.status(404).json({ error: 'User not found' });
    }

    // Provjeri trenutnu lozinku
    const isPasswordValid = await bcrypt.compare(
      currentPassword,
      user.password,
    );
    if (!isPasswordValid) {
      return res.status(401).json({ error: 'Current password is incorrect' });
    }

    // Provjeri da nova lozinka nije ista kao trenutna
    const isSameAsOld = await bcrypt.compare(newPassword, user.password);
    if (isSameAsOld) {
      return res.status(400).json({
        error: 'New password must be different from the current password',
      });
    }

    // Kriptiraj novu lozinku
    const hashedPassword = await bcrypt.hash(newPassword, 10);

    // Ažuriraj lozinku
    await user.update({ password: hashedPassword });

    // Vrati uspješan odgovor
    res.status(200).json({ message: 'Password changed successfully' });
  } catch (error) {
    console.error('Error changing password:', error);
    res.status(500).json({ error: 'Failed to change password' });
  }
};

const getOwnedRestaurants = async (req, res) => {
  try {
    const userId = req.user.id;
    const adminLinks = await UserAdmin.findAll({
      where: { userId, role: 'owner' },
      attributes: ['restaurantId'],
    });
    const restaurantIds = adminLinks.map((link) => link.restaurantId);
    const restaurants =
      restaurantIds.length > 0
        ? await Restaurant.findAll({
            where: { id: restaurantIds },
            attributes: ['id', 'name', 'place', 'slug'],
          })
        : [];
    res.json({
      restaurants: restaurants.map((r) => ({
        id: r.id,
        name: r.name,
        city: r.place,
        slug: r.slug,
      })),
    });
  } catch (error) {
    console.error('Error fetching owned restaurants:', error);
    res.status(500).json({ error: 'Failed to fetch owned restaurants' });
  }
};

const deleteAccount = async (req, res) => {
  try {
    const userId = req.user.id;

    // Briši povezane podatke
    await Promise.all([
      require('../../models').UserSettings.destroy({ where: { userId } }),
      require('../../models').UserPoints.destroy({ where: { userId } }),
      require('../../models').UserFavorite.destroy({ where: { userId } }),
      require('../../models').UserAdmin.destroy({ where: { userId } }),
      require('../../models').Review.destroy({ where: { userId } }),
      require('../../models').Reservation.destroy({ where: { userId } }),
      // Dodaj još povezane modele ako imaš
    ]);

    // Briši korisnika
    await User.destroy({ where: { id: userId } });

    res.status(200).json({ message: 'Account deleted successfully' });
  } catch (error) {
    console.error('Error deleting account:', error);
    res.status(500).json({ error: 'Failed to delete account' });
  }
};

const updatePushToken = async (req, res) => {
  try {
    const { id } = req.params;
    const { pushToken } = req.body;

    if (!pushToken) {
      return res.status(400).json({ error: 'Push token is required' });
    }

    const user = await User.findByPk(id);
    if (!user) {
      return res.status(404).json({ error: 'User not found' });
    }

    // Ažuriraj push token
    await user.update({ pushToken });

    res.status(200).json({
      message: 'Push token updated successfully',
      pushToken,
    });
  } catch (error) {
    console.error('Error updating push token:', error);
    res.status(500).json({ error: 'Failed to update push token' });
  }
};

module.exports = {
  updateUserLanguage,
  getUserLanguage,
  getUserById,
  getUserProfile,
  updateUserProfile,
  getUserStats,
  updateProfileImage,
  deleteProfileImage,
  changePassword,
  getOwnedRestaurants,
  deleteAccount,
  updatePushToken,
};
